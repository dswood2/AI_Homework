Group Number: 32
Names: Dacota Wood, Mikhail Kutepov
Question 1.1: The data structure used for implementing DFS is a Stack. A Stack follows the Last In First Out (LIFO) principle, which is important to the DFS algorithm. DFS explores as far as possible along each branch before backtracking.
Question 1.2: The exploration is as expected as it is using DFS.  When searching, it is looking for the deepest path and then backtracks when it hits an end. It then returns a path that reaches the goal, causing Pacman to bypass unnecessary explored squares.
Question 2.1: The data structure used for implementing BFS is a Queue. BFS explores the graph level by level, expanding all successors of a node before moving on to the next level. A Queue follows the First In First Out (FIFO) principle, where nodes are processed in the order they are discovered.
Question 3.1: In the UCS, the cost function considers the actual cost of reaching a particular state. It assigns a weight to each step taken by Pacman, regardless of the state or location. The implemented cost function keeps track of the step costs along the path to determine the total cost of reaching a specific state.
Question 4.1: The nullHeuristic returns a constant value of 0 for all states, making it like UCS. The Manhattan distance heuristic estimates the remaining cost to reach the goal. While nullHeuristic does not give the optimal solution, the Manhattan distance heuristic can guide A* search towards the optimal solution by considering the cost to the goal.
Question 4.2: Running A* with the Manhattan heuristic produces the best score with only 549 nodes expanded.  A* and UCS with nullHeuristic and BFS have the same score but expands 682 nodes.  Then DFS has the worst score with 806 nodes expanded.
Question 5.1: The state representation includes the current position of Pacman and a tuple of booleans indicating each of the four corners.  The boolean list represents whether Pacman has visited the corners or not. 
Question 5.2: The state space of Pacman's position and a tuple of booleans indicating visited corners. The getStartState method initializes the start state with Pacman's position and unvisited corners. The isGoalState method checks if all corners are visited. In getSuccessors, legal moves update the state, and successor information is created. The boolean indicators keep track of visited corners and are added to the successor information. 
Question 6.1: I used the Manhattan distance between the current state and the nearest unvisited corner. This heuristic is admissible as it provides a lower bound on the cost to reach the goal state. It is consistent since the heuristic value does not decrease by more than the cost of any action taken. The potential strong points of this heuristic include its efficiency and admissibility. The weakness is the inability to consider the order in which corners are visited, possibly leading to suboptimal paths.
Question 7.1: The heuristic uses the maze distance definition provided in the code which basically acts as the Manhattan distance. The strong point lies in its admissibility, ensuring the heuristic never overestimates the true cost to reach the goal. The weakness lies in inconsistency if the heuristic values for different states. This heuristic is effective, providing an estimate for the remaining cost to collect all food pellets.
Question 8.1: I use UCS to find paths to the closest food dots. The findPathToClosestDot function uses the UCS algorithm. The strong point is UCS finding the least-cost paths. UCS explores paths based on their cumulative costs, discovering the shortest path to the closest food dot. A weakness lies in the computational inefficiency of UCS, especially in scenarios with a large number of dots. 

